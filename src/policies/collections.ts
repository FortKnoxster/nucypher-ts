import {
  Capsule,
  PublicKey,
  Signature,
  Signer,
  VerifiedCapsuleFrag,
} from 'umbral-pre';

import { Bob } from '../characters/bob';
import { IUrsula } from '../characters/porter';
import { encryptAndSign, keccakDigest } from '../crypto/api';
import {
  ETH_ADDRESS_BYTE_LENGTH,
  ETH_HASH_BYTE_LENGTH,
  HRAC_LENGTH,
} from '../crypto/constants';
import {
  canonicalAddressFromPublicKey,
  toCanonicalAddress,
  toChecksumAddress,
} from '../crypto/utils';
import { PolicyMessageKit } from '../kits/message';
import { ChecksumAddress } from '../types';
import { fromHexString, toBytes } from '../utils';

import { Arrangement } from './policy';

const ARRANGEMENT_ID_LENGTH = 32;

export interface PrePublishedTreasureMap {
  hrac: Uint8Array;
  publicSignature: Uint8Array;
  payload: Uint8Array;
  id: Uint8Array;
  destinations: Record<ChecksumAddress, Uint8Array>;
}

export class PublishedTreasureMap {
  public destinations: Record<ChecksumAddress, Uint8Array>;
  private hrac: Uint8Array;
  private publicSignature: Uint8Array;
  private payload: Uint8Array;
  public readonly messageKit: PolicyMessageKit;
  private _m: number;

  constructor(
    hrac: Uint8Array,
    publicSignature: Uint8Array,
    payload: Uint8Array,
    messageKit: PolicyMessageKit,
    destinations: Record<ChecksumAddress, Uint8Array>,
    m: number
  ) {
    this.hrac = hrac;
    this.publicSignature = publicSignature;
    this.payload = payload;
    this.messageKit = messageKit;
    this.destinations = destinations;
    this._m = m;
  }

  public get m(): number {
    return this._m;
  }

  public static fromBytes(bytes: Uint8Array): PublishedTreasureMap {
    // TODO: Implement this
    throw new Error('Method not implemented.');
  }

  public orient(aliceVerifyingKey: PublicKey, bob: Bob) {
    const decryptedMap = bob.verifyFrom(
      aliceVerifyingKey,
      this.messageKit,
      true
    );
    const m = decryptedMap[0]; // TODO: This is probably wrong
    const destinations = this.bytesToDestinations(decryptedMap.slice(1));
    const actualM = Object.keys(destinations).length;
    if (actualM < m) {
      throw new Error(`Expected ${m} destinations, found ${actualM} instead.`);
    }
    this._m = m;
    this.destinations = destinations;
  }

  private bytesToDestinations(
    bytes: Uint8Array
  ): Record<ChecksumAddress, Uint8Array> {
    // TODO: Check against address format generated by Ursula
    const destinations: Record<ChecksumAddress, Uint8Array> = {};
    for (let i = 0; i < bytes.length; ) {
      const addressBytes = bytes.slice(i, i + ETH_ADDRESS_BYTE_LENGTH);
      const address = toChecksumAddress(addressBytes);
      i += ETH_ADDRESS_BYTE_LENGTH;

      const arrangementIdBytes = bytes.slice(i, i + ARRANGEMENT_ID_LENGTH);
      i += ARRANGEMENT_ID_LENGTH;

      destinations[address] = arrangementIdBytes;
    }
    return destinations;
  }
}

export class TreasureMap {
  private readonly destinations: Record<ChecksumAddress, Uint8Array>;
  private readonly m: number;

  constructor(m: number) {
    this.m = m;
    this.destinations = {};
  }

  public addArrangement(ursula: IUrsula, arrangement: Arrangement) {
    this.destinations[ursula.checksumAddress] = arrangement.getId();
  }

  public prepareForPublication(
    bobEncryptingKey: PublicKey,
    bobVerifyingKey: PublicKey,
    aliceSigner: Signer,
    label: string
  ): PrePublishedTreasureMap {
    const plaintext = this.makePlaintextToSign();

    const messageKit = encryptAndSign(
      bobEncryptingKey,
      plaintext,
      aliceSigner,
      aliceSigner.verifyingKey()
    );

    const aliceSignerPk = aliceSigner.verifyingKey().toBytes();
    const hrac = this.makeHrac(aliceSignerPk, bobVerifyingKey, label);
    const publicSignature = aliceSigner
      .sign(new Uint8Array([...aliceSignerPk, ...hrac]))
      .toBytes();
    const payload = new Uint8Array([
      ...publicSignature,
      ...hrac,
      ...messageKit.toBytes(),
    ]);
    const id = this.makeId(messageKit, hrac);
    return {
      hrac,
      publicSignature,
      payload,
      id,
      destinations: this.destinations,
    };
  }

  private makePlaintextToSign() {
    return new Uint8Array([
      ...Uint8Array.from([this.m]), // TODO: Set m to big endian?
      ...this.getDestinationsAsBytes(),
    ]);
  }

  private getDestinationsAsBytes(): Uint8Array {
    return Object.entries(this.destinations)
      .map(
        ([ursulaAddress, arrangementId]) =>
          new Uint8Array([
            ...toCanonicalAddress(ursulaAddress),
            ...arrangementId,
          ])
      )
      .reduce((next, accumulator) => new Uint8Array([...accumulator, ...next]));
  }

  private makeId(messageKit: PolicyMessageKit, hrac: Uint8Array) {
    const vk = messageKit.senderVerifyingKey.toBytes();
    return keccakDigest(new Uint8Array([...vk, ...hrac]));
  }

  private makeHrac(
    aliceSignerPk: Uint8Array,
    bobVerifyingKey: PublicKey,
    label: string
  ) {
    const hracBytes = new Uint8Array([
      ...aliceSignerPk,
      ...bobVerifyingKey.toBytes(),
      ...toBytes(label),
    ]);
    return keccakDigest(hracBytes).slice(0, HRAC_LENGTH);
  }
}

export class Revocation {
  private PREFIX: Uint8Array = toBytes('REVOKE-');
  private arrangementId: Uint8Array;
  private signature: Uint8Array;

  constructor(arrangementId: Uint8Array, signer: Signer) {
    this.arrangementId = arrangementId;
    const message = new Uint8Array([...this.PREFIX, ...arrangementId]);
    this.signature = signer.sign(message).toBytes();
  }
}

class PRETask {
  public readonly capsule: Capsule;
  private signature?: Uint8Array;

  constructor(capsule: Capsule) {
    this.capsule = capsule;
  }

  public setSignature(signature: Uint8Array) {
    this.signature = signature;
  }

  public getSpecification(
    ursulaPublicKey: Uint8Array,
    aliceAddress: Uint8Array,
    blockHash: Uint8Array,
    ursulaIdentityEvidence: Uint8Array
  ): Uint8Array {
    const expectedLengths = [
      // TODO: What is the expected length of pub key? 32 or 33 bytes?
      // [ursulaPublicKey, 'ursulaPublicKey', ?]
      {
        value: aliceAddress,
        name: 'aliceAddress',
        expectedLength: ETH_ADDRESS_BYTE_LENGTH,
      },
      {
        value: blockHash,
        name: 'blockHash',
        expectedLength: ETH_HASH_BYTE_LENGTH,
      },
    ];

    expectedLengths.forEach(({ value, name, expectedLength }) => {
      if (value.length !== expectedLength) {
        throw new Error(
          `${name} must be of length ${expectedLength}, but it's ${value.length}`
        );
      }
    });

    return new Uint8Array([
      ...this.capsule.toBytes(),
      ...ursulaPublicKey,
      ...ursulaIdentityEvidence,
      ...aliceAddress,
      ...blockHash,
    ]);
  }
}

export class WorkOrder {
  private static HEADER = toBytes('wo:');
  public readonly tasks: PRETask[];
  private bob: Bob;
  private arrangementId: Uint8Array;
  private aliceAddress: Uint8Array;
  private receiptSignature: Uint8Array;
  public readonly ursula: IUrsula;
  private blockHash: Uint8Array;
  private completed: boolean;

  public constructor(
    bob: Bob,
    arrangementId: Uint8Array,
    aliceAddress: Uint8Array,
    tasks: PRETask[],
    receiptSignature: Uint8Array,
    ursula: IUrsula,
    blockHash: Uint8Array
  ) {
    this.bob = bob;
    this.arrangementId = arrangementId;
    this.aliceAddress = aliceAddress;
    this.tasks = tasks;
    this.receiptSignature = receiptSignature;
    this.ursula = ursula;
    this.blockHash = blockHash;
    this.completed = false;
  }

  public static constructByBob(
    arrangementId: Uint8Array,
    aliceVerifyingKey: PublicKey,
    capsules: Capsule[],
    ursula: IUrsula,
    bob: Bob
  ): WorkOrder {
    const aliceAddress = canonicalAddressFromPublicKey(aliceVerifyingKey);

    // TODO: It was marked as `TODO` in `nucypher/nucypher. Should it be implemneted?
    // TODO: Bob's input to prove freshness for this work order
    const blockHash = keccakDigest(fromHexString('0x0'));

    // TODO: Implement this?
    // ursula_identity_evidence = b''
    // if ursula._stamp_has_valid_signature_by_worker():
    //     ursula_identity_evidence = ursula.decentralized_identity_evidence
    // signature = transacting_power.sign_message(message=bytes(self.stamp))
    // self.__decentralized_identity_evidence = signature
    const ursulaIdentityEvidence = fromHexString('0x0');
    const ursulaPublicKey = fromHexString(ursula.encryptingKey);

    const tasks = capsules.map((capsule) => {
      const task = new PRETask(capsule);
      const specification = task.getSpecification(
        ursulaPublicKey,
        aliceAddress,
        blockHash,
        ursulaIdentityEvidence
      );
      const taskSignature = bob.signer.sign(specification).toBytes();
      task.setSignature(taskSignature);
      return task;
    });
    const receiptSignature = this.makeReceiptSignature(
      capsules,
      ursulaPublicKey,
      bob
    );

    return new WorkOrder(
      bob,
      arrangementId,
      aliceAddress,
      tasks,
      receiptSignature,
      ursula,
      blockHash
    );
  }

  private static makeReceiptSignature(
    capsules: Capsule[],
    ursulaPublicKey: Uint8Array,
    bob: Bob
  ) {
    // TODO: It was marked as `TODO` in `nucypher/nucypher. Should it be implemented?
    // TODO: What's the purpose of the receipt? Should it include only the capsules?
    const capsulesBytes = new Uint8Array(
      capsules
        .map((c) => c.toBytes())
        .reduce(
          (next, accumulator) =>
            // TODO: This seems wasteful
            new Uint8Array([...accumulator, ...next])
        )
    );
    const receiptBytes = new Uint8Array([
      ...this.HEADER,
      ...ursulaPublicKey,
      ...capsulesBytes,
    ]);
    return bob.signer.sign(receiptBytes).toBytes();
  }

  public payload(): Uint8Array {
    throw new Error('Not implemented.');
  }
}

export class WorkOrderResult {
  private readonly _cFrag: VerifiedCapsuleFrag;
  private reencryptionSignature: Signature;

  constructor(cFrag: VerifiedCapsuleFrag, reencryptionSignature: Signature) {
    this._cFrag = cFrag;
    this.reencryptionSignature = reencryptionSignature;
  }

  public get cFrag(): VerifiedCapsuleFrag {
    return this._cFrag;
  }

  public static fromBytes(bytes: Uint8Array): WorkOrderResult {
    // TODO: What is the serialization format used here?
    throw new Error('Not implemented.');
  }
}
