import {
  Capsule,
  PublicKey,
  Signature,
  Signer,
  VerifiedCapsuleFrag,
} from 'umbral-pre';

import { Bob } from '../characters/bob';
import { IUrsula } from '../characters/porter';
import { encryptAndSign, keccakDigest } from '../crypto/api';
import {
  ETH_ADDRESS_BYTE_LENGTH,
  ETH_HASH_BYTE_LENGTH,
  HRAC_LENGTH,
} from '../crypto/constants';
import {
  canonicalAddressFromPublicKey,
  toCanonicalAddress,
  toChecksumAddress,
} from '../crypto/utils';
import { PolicyMessageKit } from '../kits/message';
import { ChecksumAddress } from '../types';

import { Arrangement } from './policy';

const ARRANGEMENT_ID_LENGTH = 32;

export interface PrePublishedTreasureMap {
  hrac: Buffer;
  publicSignature: Buffer;
  payload: Buffer;
  id: Buffer;
  destinations: Record<ChecksumAddress, Buffer>;
}

export class PublishedTreasureMap {
  public destinations: Record<ChecksumAddress, Buffer>;
  private hrac: Buffer;
  private publicSignature: Buffer;
  private payload: Buffer;
  public readonly messageKit: PolicyMessageKit;
  private _m: number;

  constructor(
    hrac: Buffer,
    publicSignature: Buffer,
    payload: Buffer,
    messageKit: PolicyMessageKit,
    destinations: Record<ChecksumAddress, Buffer>,
    m: number
  ) {
    this.hrac = hrac;
    this.publicSignature = publicSignature;
    this.payload = payload;
    this.messageKit = messageKit;
    this.destinations = destinations;
    this._m = m;
  }

  public get m(): number {
    return this._m;
  }

  public static fromBytes(bytes: Buffer): PublishedTreasureMap {
    // TODO: Implement this
    throw new Error('Method not implemented.');
  }

  public orient(aliceVerifyingKey: PublicKey, bob: Bob) {
    const decryptedMap = bob.verifyFrom(
      aliceVerifyingKey,
      this.messageKit,
      true
    );
    const m = decryptedMap[0]; // TODO: This is probably wrong
    const destinations = this.bytesToDestinations(decryptedMap.slice(1));
    const actualM = Object.keys(destinations).length;
    if (actualM < m) {
      throw new Error(`Expected ${m} destinations, found ${actualM} instead.`);
    }
    this._m = m;
    this.destinations = destinations;
  }

  private bytesToDestinations(bytes: Buffer): Record<ChecksumAddress, Buffer> {
    // TODO: Check against address format generated by Ursula
    const destinations: Record<ChecksumAddress, Buffer> = {};
    for (let i = 0; i < bytes.length; ) {
      const addressBytes = bytes.slice(i, i + ETH_ADDRESS_BYTE_LENGTH);
      const address = toChecksumAddress(addressBytes);
      i += ETH_ADDRESS_BYTE_LENGTH;

      const arrangementIdBytes = bytes.slice(i, i + ARRANGEMENT_ID_LENGTH);
      i += ARRANGEMENT_ID_LENGTH;

      destinations[address] = arrangementIdBytes;
    }
    return destinations;
  }
}

export class TreasureMap {
  private readonly destinations: Record<ChecksumAddress, Buffer>;
  private readonly m: number;

  constructor(m: number) {
    this.m = m;
    this.destinations = {};
  }

  public addArrangement(ursula: IUrsula, arrangement: Arrangement) {
    this.destinations[ursula.checksumAddress] = arrangement.getId();
  }

  public prepareForPublication(
    bobEncryptingKey: PublicKey,
    bobVerifyingKey: PublicKey,
    aliceSigner: Signer,
    label: string
  ): PrePublishedTreasureMap {
    const plaintext = this.makePlaintextToSign();

    const messageKit = encryptAndSign(
      bobEncryptingKey,
      plaintext,
      aliceSigner,
      aliceSigner.verifyingKey()
    );

    const aliceSignerPk = aliceSigner.verifyingKey().toBytes();
    const hrac = this.makeHrac(aliceSignerPk, bobVerifyingKey, label);
    const publicSignature = Buffer.from(
      aliceSigner.sign(Buffer.concat([aliceSignerPk, hrac])).toBytes()
    );
    const payload = Buffer.concat([
      publicSignature,
      hrac,
      messageKit.toBytes(),
    ]);
    const id = this.makeId(messageKit, hrac);
    return {
      hrac,
      publicSignature,
      payload,
      id,
      destinations: this.destinations,
    };
  }

  private makePlaintextToSign() {
    return Buffer.concat([
      Buffer.from([this.m]), // TODO: Set m to big endian?
      this.getDestinationsAsBytes(),
    ]);
  }

  private getDestinationsAsBytes(): Buffer {
    const toConcat: Buffer[] = [];
    Object.entries(this.destinations).forEach(
      ([ursulaAddress, arrangementId]) => {
        toConcat.push(toCanonicalAddress(ursulaAddress));
        toConcat.push(arrangementId);
      }
    );
    return Buffer.concat(toConcat);
  }

  private makeId(messageKit: PolicyMessageKit, hrac: Buffer) {
    const vk = messageKit.senderVerifyingKey.toBytes();
    return keccakDigest(Buffer.concat([vk, hrac]));
  }

  private makeHrac(
    aliceSignerPk: Uint8Array,
    bobVerifyingKey: PublicKey,
    label: string
  ) {
    const hracBytes = [
      aliceSignerPk,
      bobVerifyingKey.toBytes(),
      Buffer.from(label),
    ];
    return keccakDigest(Buffer.concat(hracBytes)).slice(0, HRAC_LENGTH);
  }
}

export class Revocation {
  private PREFIX: Buffer = Buffer.from('REVOKE-');
  private arrangementId: Buffer;
  private signature: Buffer;

  constructor(arrangementId: Buffer, signer: Signer) {
    this.arrangementId = arrangementId;
    const message = Buffer.concat([this.PREFIX, arrangementId]);
    this.signature = Buffer.from(signer.sign(message).toBytes());
  }
}

class PRETask {
  public readonly capsule: Capsule;
  private signature?: Buffer;

  constructor(capsule: Capsule) {
    this.capsule = capsule;
  }

  public setSignature(signature: Buffer) {
    this.signature = signature;
  }

  public getSpecification(
    ursulaPublicKey: Buffer,
    aliceAddress: Buffer,
    blockHash: Buffer,
    ursulaIdentityEvidence: Buffer
  ): Buffer {
    const expectedLengths = [
      // TODO: What is the expected length of pub key? 32 or 33 bytes?
      // [ursulaPublicKey, 'ursulaPublicKey', ?]
      {
        value: aliceAddress,
        name: 'aliceAddress',
        expectedLength: ETH_ADDRESS_BYTE_LENGTH,
      },
      {
        value: blockHash,
        name: 'blockHash',
        expectedLength: ETH_HASH_BYTE_LENGTH,
      },
    ];

    expectedLengths.forEach(({ value, name, expectedLength }) => {
      if (value.length !== expectedLength) {
        throw new Error(
          `${name} must be of length ${expectedLength}, but it's ${value.length}`
        );
      }
    });

    return Buffer.concat([
      this.capsule.toBytes(),
      ursulaPublicKey,
      ursulaIdentityEvidence,
      aliceAddress,
      blockHash,
    ]);
  }
}

export class WorkOrder {
  private static HEADER = Buffer.from('wo:');
  public readonly tasks: PRETask[];
  private bob: Bob;
  private arrangementId: Buffer;
  private aliceAddress: Buffer;
  private receiptSignature: Buffer;
  public readonly ursula: IUrsula;
  private blockHash: Buffer;
  private completed: boolean;

  public constructor(
    bob: Bob,
    arrangementId: Buffer,
    aliceAddress: Buffer,
    tasks: PRETask[],
    receiptSignature: Buffer,
    ursula: IUrsula,
    blockHash: Buffer
  ) {
    this.bob = bob;
    this.arrangementId = arrangementId;
    this.aliceAddress = aliceAddress;
    this.tasks = tasks;
    this.receiptSignature = receiptSignature;
    this.ursula = ursula;
    this.blockHash = blockHash;
    this.completed = false;
  }

  public static constructByBob(
    arrangementId: Buffer,
    aliceVerifyingKey: PublicKey,
    capsules: Capsule[],
    ursula: IUrsula,
    bob: Bob
  ): WorkOrder {
    const aliceAddress = canonicalAddressFromPublicKey(aliceVerifyingKey);

    // TODO: It was marked as `TODO` in `nucypher/nucypher. Should it be implemneted?
    // TODO: Bob's input to prove freshness for this work order
    const blockHash = keccakDigest(Buffer.from('0x0', 'hex'));

    // TODO: Implement this?
    // ursula_identity_evidence = b''
    // if ursula._stamp_has_valid_signature_by_worker():
    //     ursula_identity_evidence = ursula.decentralized_identity_evidence
    // signature = transacting_power.sign_message(message=bytes(self.stamp))
    // self.__decentralized_identity_evidence = signature
    const ursulaIdentityEvidence = Buffer.from('0x0', 'hex');
    const ursulaPublicKey = Buffer.from(ursula.encryptingKey, 'hex');

    const tasks = capsules.map((capsule) => {
      const task = new PRETask(capsule);
      const specification = task.getSpecification(
        ursulaPublicKey,
        aliceAddress,
        blockHash,
        ursulaIdentityEvidence
      );
      const taskSignature = Buffer.from(
        bob.signer.sign(specification).toBytes()
      );
      task.setSignature(taskSignature);
      return task;
    });
    const receiptSignature = this.makeReceiptSignature(
      capsules,
      ursulaPublicKey,
      bob
    );

    return new WorkOrder(
      bob,
      arrangementId,
      aliceAddress,
      tasks,
      receiptSignature,
      ursula,
      blockHash
    );
  }

  private static makeReceiptSignature(
    capsules: Capsule[],
    ursulaPublicKey: Buffer,
    bob: Bob
  ) {
    // TODO: It was marked as `TODO` in `nucypher/nucypher. Should it be implemented?
    // TODO: What's the purpose of the receipt? Should it include only the capsules?
    const capsulesBytes = Buffer.concat(capsules.map((c) => c.toBytes()));
    const receiptBytes = Buffer.concat([
      this.HEADER,
      ursulaPublicKey,
      capsulesBytes,
    ]);
    return Buffer.from(bob.signer.sign(receiptBytes).toBytes());
  }

  public payload(): Buffer {
    throw new Error('Not implemented.');
  }
}

export class WorkOrderResult {
  private readonly _cFrag: VerifiedCapsuleFrag;
  private reencryptionSignature: Signature;

  constructor(cFrag: VerifiedCapsuleFrag, reencryptionSignature: Signature) {
    this._cFrag = cFrag;
    this.reencryptionSignature = reencryptionSignature;
  }

  public get cFrag(): VerifiedCapsuleFrag {
    return this._cFrag;
  }

  public static fromBytes(bytes: Buffer): WorkOrderResult {
    // TODO: What is the serialization format used here?
    throw new Error('Not implemented.');
  }
}
