import * as umbral from 'umbral-pre';
import { IUrsula } from '../characters/porter';
import { Arrangement } from './policy';
import { ChecksumAddress, UmbralSigner } from '../types';
import { encryptAndSign, keccakDigest } from '../crypto/api';
import { HRAC_LENGTH } from '../crypto/constants';
import { MessageKit, PolicyMessageKit } from '../crypto/kits';
import { Alice } from '../characters/alice';
import { Bob } from '../characters/bob';

const ID_LENGTH = 32;

export interface PreparedTreasureMap {
  hrac: Buffer;
  publicSignature: Buffer;
  payload: Buffer;
  id: Buffer;
  nodes: Record<ChecksumAddress, Buffer>;
}

export class PublishedTreasureMap {
  private hrac: Buffer;
  private publicSignature: Buffer;
  private payload: Buffer;
  private messageKit: MessageKit;
  private destinations: ChecksumAddress[];

  constructor(
    hrac: Buffer,
    publicSignature: Buffer,
    payload: Buffer,
    messageKit: MessageKit,
    destinations: ChecksumAddress[],
  ) {
    this.hrac = hrac;
    this.publicSignature = publicSignature;
    this.payload = payload;
    this.messageKit = messageKit;
    this.destinations = [];
  }

  public orient(alice: Alice, bob: Bob) {
    const decryptedMap = bob.verifyFrom(alice, this.messageKit);
    const m = decryptedMap[0];
    const destinations = this.bytesToDestinations(decryptedMap.slice(1));
    if (destinations.length < m) {
      throw new Error(`Expected ${m} destinations, found ${destinations}`);
    }
    this.destinations = destinations;
    throw new Error('Method not implemented.');
  }

  private bytesToDestinations(bytes: Buffer): ChecksumAddress[] {
    // TODO: Check against address format generated by Ursula
    const destinations = [];
    for (let i = 0; i < bytes.length; ) {
      const addressBytes = bytes.slice(i, i + ID_LENGTH);
      i += ID_LENGTH;
      const address = this.toChecksumAddress(addressBytes);
      destinations.push(address);
    }
    return destinations;
  }

  public toChecksumAddress(bytes: Buffer): ChecksumAddress {
    return `0x${Buffer.from(bytes).toString('hex')}`
  }

  public static fromBytes(bytes: Buffer): PublishedTreasureMap {
    throw new Error('Method not implemented.');
  }
}

export class TreasureMap {
  private destinations: Record<ChecksumAddress, Buffer>;
  private m: number;

  constructor(m: number) {
    this.m = m;
    this.destinations = {};
  }

  public addArrangement(ursula: IUrsula, arrangement: Arrangement) {
    this.destinations[ursula.checksumAddress] = arrangement.getId();
  }

  private nodesAsBytes(): Buffer {
    const toConcat: Buffer[] = [];
    Object.entries(this.destinations).forEach(([ursulaAddress, arrangementId]) => {
      toConcat.push(toCanonicalAddress(ursulaAddress));
      toConcat.push(arrangementId);
    });
    return Buffer.concat(toConcat);
  }

  public prepareForPublication(
    bobEncryptingKey: umbral.PublicKey,
    bobVerifyingKey: umbral.PublicKey,
    aliceSigner: umbral.Signer,
    label: string
  ): PreparedTreasureMap {
    const mBytes = Buffer.from([this.m]);
    const plaintext = Buffer.concat([mBytes, this.nodesAsBytes()]);
    const messageKit = encryptAndSign(bobEncryptingKey, plaintext, aliceSigner);

    const aliceSignerPk = aliceSigner.verifyingKey().toBytes();
    const hrac = this.makeHrac(aliceSignerPk, bobVerifyingKey, label);
    const publicSignature = Buffer.from(
      aliceSigner.sign(Buffer.concat([aliceSignerPk, hrac])).toBytes()
    );
    const payload = Buffer.concat([
      publicSignature,
      hrac,
      messageKit.toBytes(),
    ]);
    const id = this.makeId(messageKit, hrac);

    return {
      hrac,
      publicSignature,
      payload,
      id,
      nodes: this.destinations,
    };
  }

  private makeId(messageKit: PolicyMessageKit, hrac: Buffer) {
    const vk = messageKit.getVerifyingKey().toBytes();
    return keccakDigest(Buffer.concat([vk, hrac]));
  }

  private makeHrac(
    aliceSignerPk: Uint8Array,
    bobVerifyingKey: umbral.PublicKey,
    label: string
  ) {
    const hracBytes = [
      aliceSignerPk,
      bobVerifyingKey.toBytes(),
      Buffer.from(label),
    ];
    const hrac = keccakDigest(Buffer.concat(hracBytes)).slice(0, HRAC_LENGTH);
    return hrac;
  }
}

const toCanonicalAddress = (address: string): Buffer => {
  const prefix = '0x';
  const nonPrefixed = address.startsWith(prefix)
    ? address.substring(prefix.length)
    : address;
  return Buffer.from(nonPrefixed, 'hex');
};

export class Revocation {
  private PREFIX: Buffer = Buffer.from('REVOKE-');
  private arrangementId: Buffer;
  private signature: Buffer;

  constructor(arrangementId: Buffer, signer: UmbralSigner) {
    this.arrangementId = arrangementId;
    const message = Buffer.concat([this.PREFIX, arrangementId]);
    this.signature = Buffer.from(signer.sign(message).toBytes());
  }
}
